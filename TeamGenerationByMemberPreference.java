import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;



public class TeamGenerationByMemberPreference implements TeamGenerationADT {
	// List to store Members not selected by the selection process
	List<Member> notSelected;
	List<Project> allProjects;

	/**
	 * Constructor just creates the Lists
	 */
	public TeamGenerationByMemberPreference() {
		allProjects = new ArrayList<Project>();
	}

	/**
	 * This is the method responsible for actually generating the teams, and is
	 * the algorithm we'll have to determine
	 */
	@Override
	public void generateProjects(PriorityQueue<Member> pq, ArrayList<Project> allProjects) {
		this.allProjects = allProjects;
		notSelected = new ArrayList<Member>();
		Member currentMember;
		boolean selected;
		System.out.println("Order");
		// While there are members left in the PQ...
		while (!pq.isEmpty()) {
			// take the top member from the PQ
			currentMember = pq.remove();
			System.out.println(currentMember.getName() + " : " + currentMember.getPriorityRanking());
			selected = false;
			
			//Adds member to their first choice if continuing else adds to not selected (Uncheck continuing to assign member to a different project)
			if (currentMember.getContinuing()) {
				if (!currentMember.getTeamChoices().get(0).isFull()
						&& currentMember.getTeamChoices().get(0).getActive()) {
					currentMember.getTeamChoices().get(0).addMember(currentMember);
					selected = true;
				}
			} 
			
			else {
				// Iterate through the list of the Member's project choices, and
				// add
				// them to their top rated that isn't full
				for (int i = 0; i < currentMember.getTeamChoices().size(); i++) {
					if (!currentMember.getTeamChoices().get(i).isFull()
							&& currentMember.getTeamChoices().get(i).getActive()
							) {
						currentMember.getTeamChoices().get(i).addMember(currentMember);
						selected = true;
						break;
					}
				}
			}
			// if all of the projects they want are full, they are added to not
			// selected
			if (!selected) {
				notSelected.add(currentMember);
			}
		}
		// once the PQ is empty, the project teams are printed
		printProjects();
	}

	/**
	 * The projects are printed, first the Projects and their Members and then
	 * the people not selected
	 */
	@Override
	public void printProjects() {
		System.out.println("Teams Generated By Member Preference:");
		System.out.println();
		for (int i = 0; i < allProjects.size(); i++) {
			if (allProjects.get(i).getActive()) {
				
				System.out.print(allProjects.get(i));
			}
		}

		System.out.println("Members Not Selected By Member Preference:");
		if (notSelected.isEmpty()) {
			System.out.println("None");

		} else {
			for (int i = 0; i < notSelected.size(); i++) {
				System.out.println(notSelected.get(i).getName());
			}
		}
		System.out.println("");
		
	}

	@Override
	public void printFinalDistribution(String Concat) {
		for (int i = 0; i < allProjects.size(); ++i) {
			if (Concat.charAt(i) == 'T') {
				allProjects.get(i).assignDay1();
			} else {
				allProjects.get(i).assignDay2();
			}
		}

		System.out.println("");
		System.out.println("------------------------------------");
		System.out.println("FINAL PROJECT DISTRIBUTION");
		System.out.println("");

		printProjects();
			try {
				File f = new File("/Users/ethanyoung/Desktop/Ethan1.txt");
				if (f.exists()) {
					f.delete();
				}
				
	            FileWriter writer = new FileWriter(new File("/Users/ethanyoung/Desktop/Ethan.txt"), true);
	            writer.write("Team\tMember 1\tMember 2\tMember 3\tMember 4\tMember 5\tMember 6\tMember 7\tMember 8\tAverage Ranking\tAverage Year\n");
	            for (int i = 0; i < allProjects.size(); ++i) {
	            	writeTeam(writer, allProjects.get(i));
	            	writer.write("\n");
	            }
	            
	            
	            
	            writer.close();
	        } catch (IOException e) {
	            e.printStackTrace();
	        }
    }

	
	public void writeTeam(FileWriter writer, Project currentProject) throws IOException{
		writer.write(currentProject.getName());
		writer.write("\t");
		for (int i = 0; i < 8; ++i) {
			if (i + 1 > currentProject.getMembers().size()) {
				writer.write("\t");
			}
			else {
				writer.write(currentProject.getMembers().get(i).getName());
				writer.write("\t");
			}
		}
		
		writer.write(Double.toString(currentProject.calculateAverageRanking()));
		writer.write("\t");
		writer.write(Double.toString(currentProject.calculateAverageYear()));
		writer.write("\t");
	
	}
	// Determines most common day of people not selected
	public int notSelectedDay(ArrayList<Member> notSelected) {
		int day1 = 0;
		int day2 = 0;

		for (int i = 0; i < notSelected.size(); ++i) {
			if (notSelected.get(i).getDay1()) {
				day1 += 1;
			}

			if (notSelected.get(i).getDay2()) {
				day2 += 1;
			}
		}

		if (day1 < day2) {
			return 2;
		} else {
			return 1;
		}

	}

	@Override
	public String generateConcatenation() {
		String concat = "";
		for (int i = 0; i < allProjects.size(); ++i) {
			if (allProjects.get(i).getDay1()) {
				concat = concat + "T";
			} else {
				concat = concat + "F";
			}
		}

		return concat + notSelected.size();
	}

}