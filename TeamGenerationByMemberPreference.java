import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

/**
 * This is the implementation of the TeamGenerationByMemberPreferenceADT, which
 * allows for the matching of members and projects. This has methods to print
 * the projects and assign members to teams.
 *
 * @author Ethan Young and David Seamon
 */
public class TeamGenerationByMemberPreference implements TeamGenerationADT {

	List<Member> notSelected; // List to store Members not selected
	List<Project> allProjects; // List to store the projects

	/**
	 * Constructor just creates the Lists
	 */
	public TeamGenerationByMemberPreference() {
		allProjects = new ArrayList<Project>();
	}

	/**
	 * This is the method responsible for actually generating the teams, and
	 * uses a priority queue to assign members to teams
	 * 
	 * @param pq:
	 *            This is the priority queue that is used to sort members for
	 *            first selection
	 * @param allProjects:
	 *            the list of the current projects that are available to be
	 *            assigned
	 */
	@Override
	public void generateProjects(PriorityQueue<Member> pq,
			ArrayList<Project> allProjects) {
		this.allProjects = allProjects;
		notSelected = new ArrayList<Member>();

		Member currentMember;
		boolean selected; // Whether a member has been assigned yet

		while (!pq.isEmpty()) {
			// Takes the top member from the PQ
			currentMember = pq.remove();

			selected = false;

			// Adds member to their first choice if continuing else adds to not
			// selected
			if (currentMember.getContinuing()) {
				if (!currentMember.getTeamChoices().get(0).isFull()
						&& currentMember.getTeamChoices().get(0).getActive()) {
					currentMember.getTeamChoices().get(0)
							.addMember(currentMember);
					selected = true;
				}
			}

			else {
				// Iterate through the list of the Member's project choices, and
				// add them to their top rated that isn't full
				for (int i = 0; i < currentMember.getTeamChoices()
						.size(); i++) {
					if (!currentMember.getTeamChoices().get(i).isFull()
							&& currentMember.getTeamChoices().get(i)
									.getActive()) {
						currentMember.getTeamChoices().get(i)
								.addMember(currentMember);
						selected = true;
						break;
					}
				}
			}
			// if all of the projects they want are full, they are added to not
			// selected
			if (!selected) {
				notSelected.add(currentMember);
			}
		}

		// once the PQ is empty, the project teams are printed
		// printProjects();
	}

	/**
	 * This method prints all of the projects in the following format:
	 * 
	 * 1) Prints the projects by calling the toString() method 2) Prints the
	 * names of the members not selected
	 */
	@Override
	public void printProjects() {
		System.out.println("Teams Generated By Member Preference:");
		System.out.println();

		// Prints the projects
		for (int i = 0; i < allProjects.size(); i++) {
			if (allProjects.get(i).getActive()) {

				System.out.print(allProjects.get(i));
			}
		}

		// Prints the members not selected
		System.out.println();
		System.out.println("Members Not Selected By Member Preference:");
		if (notSelected.isEmpty()) {
			System.out.println("None");

		} else {
			for (int i = 0; i < notSelected.size(); i++) {
				System.out.println(notSelected.get(i).getName());
			}
		}

		System.out.println();

	}

	/**
	 * This method prints all of the projects of the final distribution in the
	 * following format:
	 * 
	 * 1) Prints the projects by calling the toString() method 2) Prints the
	 * names of the members not selected
	 * 
	 * This method uses the concatenated list to rerun the simulation with the
	 * best iteration of projects allowed.
	 * 
	 * @param Concat:
	 *            The string that has the list of whether projects are active (T
	 *            for active, F for not active)
	 * @param fileName:
	 *            The name specified by the user for the output file.
	 */
	@Override
	public void printFinalDistribution(String Concat, String fileName) {
		// Assigns projects as active or not for the best sim
		for (int i = 0; i < allProjects.size(); ++i) {
			if (Concat.charAt(i) == 'T') {
				allProjects.get(i).setActive(true);
			} else {
				allProjects.get(i).setActive(false);
			}
		}

		System.out.println("");
		System.out.println("------------------------------------");
		System.out.println("FINAL PROJECT DISTRIBUTION");
		System.out.println("");

		printProjects();

		// Writes the final distribution to the file
		try {
			// Creates the file
			File f = new File(fileName);
			if (f.exists()) {
				f.delete();
			}

			// Creates the file writer
			FileWriter writer = new FileWriter(new File(fileName), true);

			writer.write("Team\t");

			// Writes the max number of members to the excel file
			for (int i = 0; i < allProjects.get(0).getMaxMembers(); i++) {
				writer.write("Member\t");
			}

			// Writes the factors to the file
			for (int i = 0; i < TeamSelector.allMembers.get(0).getFactors()
					.size(); i++) {
				writer.write(TeamSelector.allMembers.get(0).getFactors().get(i)
						.getName() + " Average\t");
			}
			writer.write("\n");

			// Writes the projects to the file
			for (int i = 0; i < allProjects.size(); ++i) {
				writeTeam(writer, allProjects.get(i));
				writer.write("\n");
			}

			writer.write("\n");
			writer.write("Not Selected Members\n");

			// Writes the not selected members to the file
			for (int i = 0; i < notSelected.size(); i++) {
				writer.write(notSelected.get(i).getName() + "\n");
			}

			writer.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Writes the members of a project to the file in the following format:
	 * 
	 * projectName member1 member2 ... Factor1 Factor2 ..
	 * 
	 * This also prints the average ranking for each project and the average
	 * year
	 * 
	 * @param Writer:
	 *            The writing object to the file
	 * @param currentProject:
	 *            the current project being written
	 */
	public void writeTeam(FileWriter writer, Project currentProject)
			throws IOException {
		// Writes the project name
		writer.write(currentProject.getName());
		writer.write("\t");

		// Writes the members to the file
		for (int i = 0; i < currentProject.getMaxMembers(); ++i) {
			if (i + 1 > currentProject.getMembers().size()) {
				writer.write("\t");
			} else {
				writer.write(currentProject.getMembers().get(i).getName());
				writer.write("\t");
			}
		}

		// Writes each factor if there are members on project
		if (currentProject.getMembers().size() > 0) {

			// Calculates the average for each project
			for (int i = 0; i < currentProject.getMembers().get(0).getFactors()
					.size(); i++) {
				writer.write(Double
						.toString(currentProject.calculateAverageFactor(i)));
				writer.write("\t");
			}
		}

	}

	/**
	 * This creates the concatenation for the current iteration. If the project
	 * is active, then there is a T in the concatenation. Else, it is an F. The
	 * not selected array size is saved at the end.
	 * 
	 * @return The concatenated string for the iteration
	 */
	@Override
	public String generateConcatenation() {
		String concat = "";

		// Adds the projects to the concatenation
		for (int i = 0; i < allProjects.size(); ++i) {
			if (allProjects.get(i).getActive()) {
				concat = concat + "T";
			} else {
				concat = concat + "F";
			}
		}

		return concat + notSelected.size();
	}

}